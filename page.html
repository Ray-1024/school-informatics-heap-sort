<html>

<head>
	<title>Пирамидальная сортировка</title>
	<script src="code.js"></script>
	<link id="Style" rel="stylesheet" href="style.css" type="text/css"/>
</head>

<body>
	<table>
		<tr>
			<td colspan ="3" align="center">
					<h1>Пирамидальная сортировка</h1>
					
			</td>			
		</tr>
		<tr>
			<td></td>
			<td class="centertd">
				<h2>Определение</h2><hr>

				<p>Двоичная куча, пирамида, или сортирующее дерево — такое двоичное дерево, для которого выполнены три условия:</p>
				<ul>
					<li>Значение в любой вершине не меньше, чем значения её потомков.</li>
					<li>Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.</li>
					<li>Последний слой заполняется слева направо без «дырок».</li>
				</ul>

				<img src="min_Heap.png" align="right">
				<p>Удобнее всего двоичную кучу хранить в виде массива a[0..n−1], у которого нулевой элемент, a[0] — элемент в корне, а потомками элемента a[i] являются a[2i+1] и a[2i+2]. Высота кучи определяется как высота двоичного дерева. То есть она равна количеству рёбер в самом длинном простом пути, соединяющем корень кучи с одним из её листьев. Высота кучи есть O(logN), где n — количество узлов дерева.</p>

			<p>Чаще всего используют кучи для минимума (когда предок не больше детей) и для максимума (когда предок не меньше детей).</p>
			
			
			
			<p>Двоичные кучи используют, например, для того, чтобы извлекать минимум из набора чисел за O(logN). Они являются частным случаем приоритетных очередей.</p>

			<br><br>
			<h2>Базовые процедуры</h2><hr>

			<h3>Восстановление свойств кучи</h3>
			<p>Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству упорядоченности. Для восстановления этого свойства служат процедуры siftDown (просеивание вниз) и siftUp (просеивание вверх).</p>

			<h3>siftDown</h3>
			<p>Если значение измененного элемента увеличивается, то свойства кучи восстанавливаются функцией siftDown.</p>
			<p>
			Работа процедуры: если i-й элемент меньше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо. В противном случае меняем местами i-й элемент с наименьшим из его сыновей, после чего выполняем siftDown для этого сына. Процедура выполняется за время O(logN).</p>
	<code >
		<pre><b>function</b> siftDown(i&nbsp;: <b>int</b>):
	    <b>while</b> 2 * i + 1 &lt; a.heapSize     
	        left = 2 * i + 1             
	        right = 2 * i + 2            
	        j = left
	        <b>if</b> right &lt; a.heapSize <b>and</b> a[right] &lt; a[left]
	            j = right
	        <b>if</b> a[i] &lt;= a[j]
	            <b>break</b>
	        swap(a[i], a[j])
	        i = j
	</pre>
	</code>

	<h3>siftUp</h3>
	<p>Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются функцией siftUp.</p>
	<p>Работа процедуры: если элемент больше своего отца, условие 1 соблюдено для всего дерева, и больше ничего делать не нужно. Иначе, мы меняем местами его с отцом. После чего выполняем siftUp для этого отца. Иными словами, слишком маленький элемент всплывает наверх. Процедура выполняется за время O(logN).</p>
	<code>
<pre><b>function</b> siftUp(i&nbsp;: <b>int</b>):
    <b>while</b> a[i] &lt; a[(i - 1) / 2]     
        swap(a[i], a[(i - 1) / 2])
        i = (i - 1) / 2
</pre>
</code>




	<h3>Извлечение минимального элемента</h3>
	<p>Выполняет извлечение минимального элемента из кучи за время O(logn). Извлечение выполняется в четыре этапа:</p>
	<ol>
		<li>Значение корневого элемента (он и является минимальным) сохраняется для последующего возврата.</li>
		<li>Последний элемент копируется в корень, после чего удаляется из кучи.</li>
		<li>Вызывается siftDown для корня</li>
		<li>Сохранённый элемент возвращается.</li>
	</ol>

	<code>
<pre><b>int</b> extractMin():
    <b>int</b> min = a[0]
    a[0] = a[a.heapSize - 1]
    a.heapSize = a.heapSize - 1
    siftDown(0)
    <b>return</b> min
</pre>
</code>


<h3>Добавление нового элемента</h3>
<p>Выполняет добавление элемента в кучу за время O(logn). Добавление произвольного элемента в конец кучи, и восстановление свойства упорядоченности с помощью процедуры siftUp.</p>

<code>
<pre><b>function</b> insert(key&nbsp;: <b>int</b>):
    a.heapSize = a.heapSize + 1
    a[a.heapSize - 1] = key
    siftUp(a.heapSize - 1)
</pre>
</code>

<h2>Пример работы</h2><hr>
			<code>Введите колличество элементов массива:</code><input type="text" size="5" id="inputN"/>
			<button onClick="Gen();">Ввести массив</button>
	<div id="Input">	</div>
	<div id="Output">
		
		</div>

	

	<h2>Источники</h2><br><hr>
	<ul>
	<li><a href="https://neerc.ifmo.ru/wiki/index.php?title=Сортировка_кучей">Викиконспекты: Сортировка кучей</a></li>
	<li><a href="https://ru.wikipedia.org/wiki/Пирамидальная_сортировка"> Wikipedia: Пирамидальная сортировка</a></li>
	</ul>

			</td>

			<td></td>			
		</tr>

	</table>
<hr>
<button onClick="otherStyle(0);">Без стиля страницы</button>
<button onClick="otherStyle(1);">Бежевый стиль страницы</button>
<button onClick="otherStyle(2);">Синий стиль страницы</button>
<br>
Сковородников Дмитрий Алексеевич 
</body>

</html>